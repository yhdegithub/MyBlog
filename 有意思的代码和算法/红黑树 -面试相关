没有必要记住这么详细。但是你要记住这些算法到底解决了什么问题，有哪些好处，
  以及其中的一些线索，可以在需要的时候自己重新推导出来。


## 1. 简要介绍下红黑树？

   红黑树是平衡二叉树的一种妥协折中的特例 ，给每个二叉树节点附加一个color变量来模拟一颗相对平衡的2-3树，
   经常用于查找操作 。 在普通查找时 ，AVL和RB-tree效率差不多 ，但是AVL追求最对的平衡 ，导致在插入 ，删除
   节点时候 ，尤其是批量操作时 ，AVL需要维持平衡的rebalance操作次数过于频繁 ，使得人们妥协地选择RB-tree ，
   使这个rebalanace频率大大降低 ， 插入和删除操作带来的旋转次数减少 ，但查找速度又不会收到很大影响 ，都是
   O(lgN)。
  
## 2. 应用场景

   Java中的HashMap TreeSet ,TreeMap都借鉴了种种数据结构实现 。  其中TreeMap采用了RB-tree ，而HashMap采用
   hash + 拉链法 + RB-tree ，所以最坏情况两种效率相同都是O(h)，但是一般和较好情况时 ，HashMap只需要使用O(1)
   的复杂度 ，所以从整体来讲 ，HashMap性能更优。
   
    查找速度, 数据量, 内存使用，可扩展性。
　　总体来说，hash查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。
   并不一定常数就比log(n) 小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，
   考虑考虑hash。但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，
    特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。

## 3.  RB-tree 特征

 RB-tree被认为有五大特征 ，但是可以根据Robert编写的算法橘皮书而言 ，按照一定约定 ， 它的特性可以大大简化 ，同时
 也极为方便建立一颗RB-tree并且维护它的特性。
 
 1） 根节点是黑色的
 
 2） 一个结点要么红 ，要么黑
 
 3） 一个结点不能同时连接到两个红结点
 
 4）红结点都设定为左结点 ，插入时 ，默认构造一个红色结点
 
 5） 从根结点出发 ，每条路径所经过的黑结点数目是平衡的（差值<=1） ，由4）可得 ，最长路径保证 <= 2 *最短路径 ，这就
 使得插入性能差不多
 
## 4. 操作  


三板斧 ： 左旋 ，右旋 ，变换颜色 ，参考笔记本或者橘皮书。

插入 ：
从根结点出发 ，插入一个结点 ，默认为红。
  1）若结点右红左黑 ，则左旋
  2）左红 ，左左红 ，则右旋
  3）左右都红 ，则变换颜色
  插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。
  最后再保证全局变量root.color = black即可

删除 ：
删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。
需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，
将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。

删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，
就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。

删除修复操作分为四种情况(删除黑节点后)：

待删除的节点的兄弟节点是红色的节点。
待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。
待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，
如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。
待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，
则就是对应的就是左节点是红色的。
   

   
