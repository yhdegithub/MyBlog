# 巧妙思维，不用再记二叉树的后序费递归算法啦 ！

最近实习完，一直都没有更新博客了。看到互联网面试经常考察二叉树的相关知识，尤其是后序非递归算法的写法，可是脑子不好使 ，写了半天才写出来那种经典的pre-cur写法， 于是想了想，怎么能写出一种简单的二叉树后序非递归遍历，这是我看比较前序和中序非递归，突然想出来的一种解法 ，觉得很有意义，所以就记录了下来。

##  经典写法

后序变比的基本思想是 ：标志已经访问过的结点

1）使用栈，保存每个结点到最左孩子的一条完整路径

2）取栈顶元素 ，如果是发现该元素的右节点已被访问，或者为空，则修改pre ,cur ,当前的cur即是正该访问的结点 ，注意取cur= null ，不然后面的while循环跳不出来

3）否则，就按次访问该节点的右孩子

核心部分代码如下 ：

  ![](C:\Users\Asus\Desktop\后序非递归经典.JPG)

## 奇妙解答

树的经典后序非递归算法 ，需要使用cur和pre相继做标志，比较难以记忆 ，这里提供一种简单的写法。

我们考虑前序和后序的遍历顺序，L代表左孩子 ，R代表右孩子 ，D代表根节点 。 前序遍历是DLR ，后序遍历是LRD 。 仔细观察遍历顺序 ，如果我们把前序遍历的DLR改成DRL， 在经过一次翻转，就可以得到后序遍历LRD 。是不是很神奇 ？ 而且前序非递归算法是很好写 ，我们在前序的基础之上，把左右孩子入栈顺序给换了 ，就可以实现，得到DRL了 。 最后的结果不要忘了翻转。

代码如下 ：

![](C:\Users\Asus\Desktop\后序非递归简化.JPG) 

这种方法记忆起来就简单多了 ，还可以和前序非递归一起记了。 但是 ，也有缺点 ，主要是引入了后期的翻转开销 ，如果树的结点比较多的话 ，可能会带来一点损耗。



